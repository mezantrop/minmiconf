#!/bin/sh

# ---------------------------------------------------------------------------- #
# Note, this is not an autotools configure script, Minimum Minimorum Configure #
# (MinMiCon) script is written for my humble needs to set values in a Makefile #
# ---------------------------------------------------------------------------- #

# -- Script variables -------------------------------------------------------- #
_DEBUG="y"
scriptname=`basename $0`		# Scriptname. Should we care if $0 = sh?

# ---------------------------------------------------------------------------- #
init() {
    # -- Makefile variables to be set ---------------------------------------- #

    # TODO
    # * Detect cc
    # * Use WITH_* variables!
    # * distinguish script maintenance variables from exported and detected ones

    CC=cc
    PREFIX_PATH_CANDIDATES="/opt /usr/local $HOME"

    WITH_TCP_NODELAY=${WITH_TCP_NODELAY=1}
    USER=${USER=`whoami`}
    PREFIX=${PREFIX=`detect_path "$PREFIX_PATH_CANDIDATES" "drw" ""`}

    INCLUDE_PATH_CANDIDATES="/usr/include $PREFIX/include"
    LIB_PATH_CANDIDATES="/lib /usr/lib /usr/lib32 $PREFIX/lib"
    LIB_PATH=${LIB_PATH=`detect_lib_path "$LIB_PATH_CANDIDATES" "dr" "all"`}


    # -- Action variables ---------------------------------------------------- #
    SET_VARS="WITH_TCP_NODELAY USER PREFIX"

    # PREFIX WITH_LIBSSH2
}

# ---------------------------------------------------------------------------- #
_ifdebug() {

    #
    # Check debug mode - _DEBUG variable is set to:
    #   - "yY" or "[1-9]" and return 0
    #   - "nN" or 0 and return 1
    #  On any error return 2
    #

    case "$_DEBUG" in
        0|[nN])        return 1 ;;
        [1-9]|[yY])    return 0 ;;
        *)             return 2 ;;
    esac
}

# ---------------------------------------------------------------------------- #
_dprintf() {
    #
    # Print a message from $* if in debug mode
    #

    _ifdebug && printf "DEBUG: %s\n" "$*" >&2
}

# ---------------------------------------------------------------------------- #
detect_path() {
    #
    # Detect valid path(s) from a list
    #
    # $1 - Space separated path specifications
    # $2 - permissions to check (dfrwx)
    # $3 - 1 or "all" to print all valid; 0 or "" to show the first one only
    # Output: Prints matched path(s) or empty string on error
    # Return: 0 - on success, 1 on failure or error
    #

    _path="$1"
    # Prepare permissions string for iteration: "DRWX" -> "d r w x "
    _prms="`echo "$2" |
        sed -e 's/\([a-z]\)/\1 /g' \
            -e 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`"
    case  "$3" in
        0|"")
            _all=0
            _dprintf "detect_path(): Print all valid: disabled"
        ;;

        1|all)
            _all=1
            _dprintf "detect_path(): Print all valid: enabled"
        ;;

        *)
            _dprintf "detect_path(): Argument \$3: [$3] is not valid"
            return 1
        ;;
    esac
    _dprintf "Print all valid: [$_all]"

    _rcode=0
    for _p in $_path; do
        _inp=0
        _acp=0
        _ifdebug && _dout=""
        _dprintf "detect_path(): Checking: [$_p]"
        for _prm in $_prms; do
            case "$_prm" in
                *d*)
                    _inp=`expr $_inp + 1`
                    [ -d "$_p" ] && {
                        _acp=`expr $_acp + 1`
                        _ifdebug && _dout="$_dout""d"
                    } || break;
                ;;

                *f*)
                    _inp=`expr $_inp + 10`
                    [ -f "$_p" ] && {
                        _acp=`expr $_acp + 10`
                        _ifdebug && _dout="$_dout""f"
                    } || break;
                ;;

                *r*)
                    _inp=`expr $_inp + 100`
                    [ -r "$_p" ] && {
                        _acp=`expr $_acp + 100`
                        _ifdebug && _dout="$_dout""r"
                    } || break;
                ;;

                *w*)
                    _inp=`expr $_inp + 1000`
                    [ -w "$_p" ] && {
                        _acp=`expr $_acp + 1000`
                        _ifdebug && _dout="$_dout""w"
                    } || break;
                ;;

                *x*)
                    _inp=`expr $_inp + 10000`
                    [ -x "$_p" ] && {
                        _acp=`expr $_acp + 10000`
                        _ifdebug && _dout="$_dout""x"
                    } || break;
                ;;

                *)
                    _dprintf "detect_path(): Path: wrong permissions argument"
                    echo ""
                    return 1
                ;;
            esac
        done

        [ $_inp -eq $_acp ] && {
            _rcode=0
            _dprintf "detect_path(): Valid path: [$_dout] [$_p]"
            printf "%s " "$_p"
            if [ $_all -eq 0 ]; then return 0; fi
        } || {
            _rcode=1
            _dprintf "detect_path(): NOT valid: [$_p] Score: $_inp/$_acp"
        }
    done

    [ ! $_rcode ] && {
        _dprintf "detect_path(): No valid path detected"
        echo ""
        return 1
    } || return 0
}

# ---------------------------------------------------------------------------- #
detect_lib_path() {
    #
    # Detect valid linrary path(s) from a list
    #
    # $1 - Space separated path specifications
    # $2 - permissions to check (dfrwx)
    # $3 - 1 or "all" to print all valid; 0 or "" to show the first one only
    # Output: Prints matched path(s) or empty string on error
    # Return: 0 - on success, 1 on failure or error
    #

    for l in `detect_path "$LIB_PATH_CANDIDATES" "dr" "all"`; do
        printf "\-L%s " "$l"
    done
}

# ---------------------------------------------------------------------------- #
detect_library() {
    #
    # Detect library with name $1 exists using $2 path(s) list as hints
    #

    _tlib="$1"
    _libs="$2"
    _tmpd=`mktemp -d ./$scriptname.XXXXXX` || {
        _dprintf "detect_library(): Failed creating a temporary directory"
        return 1
    }
    _testc="$_tmpd/ctest.c"

    echo "int main() {return 0;}" > $_testc
    $CC $_testc -o $_testc.out -l"$_tlib" "$_libs" > /dev/null 2>&1 && {
        rm -r $_tmpd
        _dprintf "detect_library(): Library: [$_tlib] found"
        return 0
    } || {
        rm -r $_tmpd
        _dprintf "detect_library(): Library: [$_tlib] not found"
        return 1
    }
}

# ---------------------------------------------------------------------------- #
detect_user() {
    #
    # Detect and return current username; Respects USER and WITH_USER variables
    #

    [ -n "$USER" ] && _user="$USER"
    [ -n "$WITH_USER" ] && _user="$WITH_USER"
    _user=${_user=`whoami`}

    echo "$_user"
    _dprintf "detect_user(): detected user: [$_user]"
    [ -n $_user ] && return 0 || return 1
}

# ---------------------------------------------------------------------------- #
write_vars() {
    #
    # Write variables and their values into a file
    #
    # $1 - a string containing space separated variable names
    # $2 - a file to write or (update) the variables
    #

    _vars=$1
    _file=$2
    _var_rgx="^[:space:]*"
    _val_rgx="[:space:]*[a-zA-Z0-9[:punct:]]*"

    for i in $_vars; do
        _var="$i"
        _val="`eval echo '$'{$i}`"

        # Find if variable is in the file
        [ "`grep "$_var_rgx$_var=$_vrgx" "$_file"`" ] && {
            # Update the variable value...
            _dprintf "write_vars(): Updating [$_var] = [$_val] > [$_file]"
            sed -i '' 's|'"$_var_rgx"''"$_var"'='"$_val_rgx"'|'"$_var"'='"$_val"'|' $_file
        } || {
            # ... or initiate it with the value
            _dprintf "write_vars(): Creating [$_var] = [$_val] > [$_file]"
            _f=`cat $_file`
            printf "%s=%s\n%s" "$_var" "$_val" "$_f" > $_file
        }
    done
}

# ---------------------------------------------------------------------------- #
init

write_vars "$SET_VARS" "mfile"

echo OUT "$PREFIX"
echo OUT "$LIB_PATH"

detect_library "c" "$LIB_PATH"

detect_user
