#!/bin/sh

# ---------------------------------------------------------------------------- #
# Note, this is not an autotools configure script, Minimum Minimorum Configure #
# (MinMiCon) script is written for my humble needs to set values in a Makefile #
# ---------------------------------------------------------------------------- #

# -- Script variables -------------------------------------------------------- #
_DEBUG="y"
scriptname=`basename $0`		# Scriptname. Should we care if $0 = sh?

# ---------------------------------------------------------------------------- #
# CC_CANDIDATES="cc clang gcc"
PREFIX_PATH_CANDIDATES="/usr/local /opt $HOME"
INCLUDE_PATH_CANDIDATES="/usr/include $PREFIX/include"
LIB_PATH_CANDIDATES="/lib /usr/lib /usr/lib32 $PREFIX/lib"

SET_VARS="WITH_TCP_NODELAY WITH_USER PREFIX"

    # PREFIX WITH_LIBSSH2

# ---------------------------------------------------------------------------- #
_ifdebug() {

    #
    # Check debug mode - _DEBUG variable is set to:
    #   - "yY" or "[1-9]" and return 0
    #   - "nN" or 0 and return 1
    #  On any error return 2
    #

    case "$_DEBUG" in
        0|[nN])        return 1 ;;
        [1-9]|[yY])    return 0 ;;
        *)             return 2 ;;
    esac
}

# ---------------------------------------------------------------------------- #
_dprintf() {

    #
    # Print a message from $* if in debug mode
    #

    _ifdebug && printf "DEBUG: %s\n" "$*" >&2
}

# ---------------------------------------------------------------------------- #
_in() {

    #
    # String-in-string. Return 0 if $2 is in $1, otherwise return 1
    #

    echo "$1" | grep -q "$2" && return 0 || return 1
}

# ---------------------------------------------------------------------------- #
detect_path() {

    #
    # Detect valid path(s) from a list
    #
    # $1 - Results variable
    # $2 - Space separated path specifications
    # $3 - permissions to check (dfrwx), default: "frx"
    # $4 - 1/"all" to print all valid (default); 0/"" to show the 1-st one only
    # Output: Prints matched path(s) or empty string on error
    # Return: 0 - on success, 1 on failure or error
    #

    _out=''
    _path="$2"
    # Prepare permissions string for iteration: "DRWX" -> "d r w x "
    [ -n "$3" ] &&
        _prms="`echo "$3" |
            sed -e 's/\([a-z]\)/\1 /g' \
                -e 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`" ||
        _prms="frx"

    [ -z "$4" ] && _all=1 ||
        case "$4" in
            [oO][nN][eE])
                _all=0
                _dprintf "detect_path(): Print all valid: disabled"
            ;;

            [aA][lL][lL])
                _all=1
                _dprintf "detect_path(): Print all valid: enabled"
            ;;

            *)
                _dprintf "detect_path(): Argument \$4: [$4] is not valid"
                eval $1=''                      # Return value
                return 1
            ;;
        esac

    _dprintf "Print all valid: [$_all]"

    _rcode=1
    for _p in $_path; do
        _inp=0
        _acp=0
        _ifdebug && _dout=""
        _dprintf "detect_path(): Checking: [$_p]"
        for _prm in $_prms; do
            case "$_prm" in
                *d*)
                    _inp=`expr $_inp + 1`
                    [ -d "$_p" ] && {
                        _acp=`expr $_acp + 1`
                        _ifdebug && _dout="$_dout""d"
                    } || break;
                ;;

                *f*)
                    _inp=`expr $_inp + 10`
                    [ -f "$_p" ] && {
                        _acp=`expr $_acp + 10`
                        _ifdebug && _dout="$_dout""f"
                    } || break;
                ;;

                *r*)
                    _inp=`expr $_inp + 100`
                    [ -r "$_p" ] && {
                        _acp=`expr $_acp + 100`
                        _ifdebug && _dout="$_dout""r"
                    } || break;
                ;;

                *w*)
                    _inp=`expr $_inp + 1000`
                    [ -w "$_p" ] && {
                        _acp=`expr $_acp + 1000`
                        _ifdebug && _dout="$_dout""w"
                    } || break;
                ;;

                *x*)
                    _inp=`expr $_inp + 10000`
                    [ -x "$_p" ] && {
                        _acp=`expr $_acp + 10000`
                        _ifdebug && _dout="$_dout""x"
                    } || break;
                ;;

                *)
                    _dprintf "detect_path(): Path: wrong permissions argument: [$_prm]"
                    eval $1=''                  # Return value
                    return 1
                ;;
            esac
        done

        [ $_inp -eq $_acp ] && {
            _rcode=0
            _dprintf "detect_path(): Valid path: [$_dout] [$_p]"
            [ -z "$_out" ] && _out="$_p" || _out="$_out $_p"
            if [ $_all -eq 0 ]; then
                eval $1='$_p'                   # Return value
                return 0
            fi
        } || {
            _dprintf "detect_path(): NOT valid: [$_p] Score: $_inp/$_acp"
        }
    done

    [ ! $_rcode ] && {
        _dprintf "detect_path(): No valid path detected"
        eval $1=''                              # Return value
        return 1
    } || {
        eval $1='$_out'                         # Return value
        return 0
    }
}

# ---------------------------------------------------------------------------- #
detect_lib_path() {

    #
    # Detect valid linrary path(s) from a list and or LIB_PATH_CANDIDATES
    #
    # $1 - Results variable
    # $2 - Space separated path specifications
    # $3 - permissions to check (dfrwx)
    # $4 - 1 or "all" to print all valid; 0 or "" to show the first one only
    # Output: Prints matched path(s) or empty string on error
    # Return: 0 - on success, 1 on failure or error
    #

    [ -z "$2" -a -z "$LIB_PATH_CANDIDATES" ] && {
        _dprintf "detect_lib_path(): Neither LIB_PATH_CANDIDATES nor \$1 argument is set"
        eval $1=''                              # Return value
        return 1
    }
    _lpath="$2"
    _perms="$3"
    _scope="$4"
    [ -n "$LIB_PATH_CANDIDATES" -a "$_lpath" != "$LIB_PATH_CANDIDATES" ] &&
        _lpath="$_lpath $LIB_PATH_CANDIDATES"
    [ -n "$3" ] && _perms="$3" ||_perms="dr"
    [ -n "$4" ] && _scope="$4" || _scope="all"

    detect_path "_dp" "$_lpath" "$_perms" "$_scope"
    [ $? -gt 0 ] && {
        _dprintf "detect_lib_path(): No available library paths"
        eval $1=''                              # Return value
        return 1
    }

    _out=""                     # Clean _out spoiled by detect_lib_path()
    for l in $_dp; do
        [ -z "$_out" ] && _out="-L$l" || _out="$_out -L$l"
    done

    _dprintf "detect_lib_path(): [$_out]"
    eval $1='$_out'                             # Return value
    return 0
}

# ---------------------------------------------------------------------------- #
detect_library() {

    #
    # Detect existence of a library by its filename
    #
    # $1 - Results variable
    # $2 - Library name to detect
    # $3 - Optional path(s) in addition to LIB_PATH_CANDIDATES to detect the lib


    [ -n "$2" ] && _tlib="$2" || {
        _dprintf "detect_library(): Missing library to detect"
        return 1
    }

    [ -n "$3" ] && _lpath="$3"
    [ -n "$WITH_LIB_PATH" -a "$_lpath" != "$LIB_PATH_CANDIDATES" ] &&
        _lpath="$_lpath $LIB_PATH_CANDIDATES"

    [ -z "$CC" ] && {
        _dprintf "detect_library(): Missing C-compiler"
        return 1
    }

    _tmpd=`mktemp -d ./$scriptname.XXXXXX` || {
        _dprintf "detect_library(): Failed creating a temporary directory"
        return 1
    }
    _testc="$_tmpd/ctest.c"

    echo "int main() {return 0;}" > $_testc
    $CC $_testc -o $_testc.out -l"$_tlib" $_libs > /dev/null 2>&1
    _r=$?
    eval $1='$_tlib'
    rm -r $_tmpd
    [ $_r -eq 0 ] && {
        _dprintf "detect_library(): Library: [$_tlib] found"
        return 0
    } || {
        _dprintf "detect_library(): Library: [$_tlib] not found"
        return 1
    }
}

# ---------------------------------------------------------------------------- #
detect_cc() {
    #
    # Detect C-compiler
    # $1 - Results variable
    # $2 - Compiler candidates in addition to CC_CANDIDATES variable
    #

    [ -n "$2" ] && _ccs="$2" || _ccs=""
    [ -n "$CC_CANDIDATES" -a "$_ccs" != "$CC_CANDIDATES" ] &&
        _ccs="$_ccs $CC_CANDIDATES"

    _save_cc="$CC"                              # Save CC value
    for _cc in $_ccs; do
        CC="$_cc"
        # Does cc really works?
        which "$CC" > /dev/null 2>&1 &&
            detect_library LIB_NAME "c" "$LIB_PATH" > /dev/null 2>&1 && {

            eval $1='$CC'
            _dprintf "detect_cc(): [$CC] found"
             [ "$1" != "CC" ] && CC=$_save_cc   # Restore CC
            return 0
        }
    done

    eval $1=''
    _dprintf "detect_cc(): $_ccs not found"
    return 1
}

# ---------------------------------------------------------------------------- #
detect_target() {

    #
    # Detect target triplet: machine-vendor-os
    # $1 - Results variable
    #

    # Very rough approach
    _machine=`uname -m`
    _vendor="unknown"
    _os=`uname -s`

    [ "$_machine" == "amd64" ] && _machine="x86_64"
    _triplet="$_machine-$_vendor-$_os"

    _dprintf "detect_target(): [$_triplet]"
    eval $1='$_triplet'
    return 0
}

# ---------------------------------------------------------------------------- #
detect_user() {

    #
    # Detect current username; Respects USER and WITH_USER variables
    # $1 - Results variable
    #

    [ -n "$USER" ] && _user="$USER"
    [ -n "$WITH_USER" ] && _user="$WITH_USER"
    _user=${_user=`whoami`}

    eval $1='$_user'
    _dprintf "detect_user(): detected user: [$_user]"
    [ -n $_user ] && return 0 || return 1
}

# ---------------------------------------------------------------------------- #
write_vars() {

    #
    # Write variables and their values into a file
    #
    # $1 - a string containing space separated variable names
    # $2 - a file to write or (update) the variables
    #

    _vars=$1
    _file=$2
    _var_rgx="^[:space:]*"
    _val_rgx="[:space:]*[a-zA-Z0-9[:punct:]]*"

    for i in $_vars; do
        _var="$i"
        _val="`eval echo '$'{$i}`"

        # Find if variable is in the file
        [ "`grep "$_var_rgx$_var=$_vrgx" "$_file"`" ] && {
            # Update the variable value...
            _dprintf "write_vars(): Updating [$_var] = [$_val] > [$_file]"
            sed -i '' 's|'"$_var_rgx"''"$_var"'='"$_val_rgx"'|'"$_var"'='"$_val"'|' $_file
        } || {
            # ... or initiate it with the value
            _dprintf "write_vars(): Creating [$_var] = [$_val] > [$_file]"
            _f=`cat $_file`
            printf "%s=%s\n%s" "$_var" "$_val" "$_f" > $_file
        }
    done
}

# ---------------------------------------------------------------------------- #
check() {

    #
    # Checking for wrapper with yes/no result output
    # $* is a function with arguments to run
    # Returns 0 on success or 1 if a failure occured

    case "$1" in
        detect_*)
            _target=`echo $1 | cut -f 2,3 -d '_'`
        ;;

        *)
            _target=$1
        ;;
    esac

    printf "Checking: %16s: " "$_target"
    # In squre brackets _in greps for '$' and decides to eval variable or not
    eval $@ && {
        printf "%-5s" "yes:"
        eval echo '$'$2
     } || {
        printf "%-5s" "no :"
        _in "$3" '\$' && eval echo $3 || echo $3
     }
}

# ---------------------------------------------------------------------------- #
check detect_path       "PREFIX"    '"$PREFIX_PATH_CANDIDATES" "drw" "one"'
check detect_lib_path   "LIB_PATH"  '"$LIB_PATH_CANDIDATES" "dr" "all"'
check detect_target     "TARGET"
check detect_cc         "CC"        'cc'
check detect_library    "LIBC"      'c'
check detect_library    "LIBQWE"    'qwe'


# check_for detect_library ssh2

# write_vars "$SET_VARS" "mfile"
